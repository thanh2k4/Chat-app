// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addChatMember = `-- name: AddChatMember :one
INSERT INTO chat.chat_members (id, chat_id, user_id, role, status)
VALUES ($1, $2, $3, $4, 'active')
    ON CONFLICT (chat_id, user_id) DO UPDATE SET status = 'active'
                                          RETURNING id, chat_id, user_id, role, status, joined_at
`

type AddChatMemberParams struct {
	ID     pgtype.UUID `json:"id"`
	ChatID pgtype.UUID `json:"chat_id"`
	UserID pgtype.UUID `json:"user_id"`
	Role   string      `json:"role"`
}

func (q *Queries) AddChatMember(ctx context.Context, arg AddChatMemberParams) (ChatChatMember, error) {
	row := q.db.QueryRow(ctx, addChatMember,
		arg.ID,
		arg.ChatID,
		arg.UserID,
		arg.Role,
	)
	var i ChatChatMember
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Role,
		&i.Status,
		&i.JoinedAt,
	)
	return i, err
}

const createChat = `-- name: CreateChat :one
INSERT INTO chat.chats (id, type, name, creator_id)
VALUES ($1, $2, $3, $4)
    RETURNING id, type, name, creator_id, created_at, updated_at
`

type CreateChatParams struct {
	ID        pgtype.UUID `json:"id"`
	Type      string      `json:"type"`
	Name      pgtype.Text `json:"name"`
	CreatorID pgtype.UUID `json:"creator_id"`
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (ChatChat, error) {
	row := q.db.QueryRow(ctx, createChat,
		arg.ID,
		arg.Type,
		arg.Name,
		arg.CreatorID,
	)
	var i ChatChat
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.CreatorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatByID = `-- name: GetChatByID :one
SELECT id, type, name, creator_id, created_at, updated_at FROM chat.chats WHERE id = $1
`

func (q *Queries) GetChatByID(ctx context.Context, id pgtype.UUID) (ChatChat, error) {
	row := q.db.QueryRow(ctx, getChatByID, id)
	var i ChatChat
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.CreatorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatMembers = `-- name: GetChatMembers :many
SELECT id, chat_id, user_id, role, status, joined_at FROM chat.chat_members WHERE chat_id = $1
`

func (q *Queries) GetChatMembers(ctx context.Context, chatID pgtype.UUID) ([]ChatChatMember, error) {
	rows, err := q.db.Query(ctx, getChatMembers, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatChatMember
	for rows.Next() {
		var i ChatChatMember
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.UserID,
			&i.Role,
			&i.Status,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberByChatID = `-- name: GetMemberByChatID :many
SELECT user_id FROM chat.chat_members WHERE chat_id = $1
`

func (q *Queries) GetMemberByChatID(ctx context.Context, chatID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getMemberByChatID, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var user_id pgtype.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByChatID = `-- name: GetMessagesByChatID :many
SELECT id, chat_id, sender_id, content, type, media_url, status, created_at, updated_at FROM chat.messages WHERE chat_id = $1 ORDER BY created_at ASC
`

func (q *Queries) GetMessagesByChatID(ctx context.Context, chatID pgtype.UUID) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getMessagesByChatID, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.Type,
			&i.MediaUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadMessages = `-- name: GetUnreadMessages :many
SELECT id, chat_id, sender_id, content, type, media_url, status, created_at, updated_at FROM chat.messages WHERE chat_id = $1 AND id NOT IN (
    SELECT message_id FROM chat.message_status WHERE user_id = $2 AND status = 'read'
) ORDER BY created_at ASC
`

type GetUnreadMessagesParams struct {
	ChatID pgtype.UUID `json:"chat_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetUnreadMessages(ctx context.Context, arg GetUnreadMessagesParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getUnreadMessages, arg.ChatID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.Type,
			&i.MediaUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessageAsRead = `-- name: MarkMessageAsRead :exec
INSERT INTO chat.message_status (message_id, user_id, status, read_at)
VALUES ($1, $2, 'read', NOW())
    ON CONFLICT (message_id, user_id) DO UPDATE SET status = 'read', read_at = NOW()
`

type MarkMessageAsReadParams struct {
	MessageID pgtype.UUID `json:"message_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

func (q *Queries) MarkMessageAsRead(ctx context.Context, arg MarkMessageAsReadParams) error {
	_, err := q.db.Exec(ctx, markMessageAsRead, arg.MessageID, arg.UserID)
	return err
}

const removeChatMember = `-- name: RemoveChatMember :exec
UPDATE chat.chat_members SET status = 'left' WHERE chat_id = $1 AND user_id = $2
`

type RemoveChatMemberParams struct {
	ChatID pgtype.UUID `json:"chat_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) RemoveChatMember(ctx context.Context, arg RemoveChatMemberParams) error {
	_, err := q.db.Exec(ctx, removeChatMember, arg.ChatID, arg.UserID)
	return err
}

const sendMessage = `-- name: SendMessage :one
INSERT INTO chat.messages (id, chat_id, sender_id, content, type, media_url, status)
VALUES ($1, $2, $3, $4, $5, $6, 'sent')
    RETURNING id, chat_id, sender_id, content, type, media_url, status, created_at, updated_at
`

type SendMessageParams struct {
	ID       pgtype.UUID `json:"id"`
	ChatID   pgtype.UUID `json:"chat_id"`
	SenderID pgtype.UUID `json:"sender_id"`
	Content  pgtype.Text `json:"content"`
	Type     string      `json:"type"`
	MediaUrl pgtype.Text `json:"media_url"`
}

func (q *Queries) SendMessage(ctx context.Context, arg SendMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, sendMessage,
		arg.ID,
		arg.ChatID,
		arg.SenderID,
		arg.Content,
		arg.Type,
		arg.MediaUrl,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.SenderID,
		&i.Content,
		&i.Type,
		&i.MediaUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMessageStatus = `-- name: UpdateMessageStatus :exec
UPDATE chat.messages SET status = $2 WHERE id = $1
`

type UpdateMessageStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateMessageStatus(ctx context.Context, arg UpdateMessageStatusParams) error {
	_, err := q.db.Exec(ctx, updateMessageStatus, arg.ID, arg.Status)
	return err
}
